# -*- coding: utf-8 -*-
"""SegComp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U25LoiAZuyqazkoXPCn8rRS91e87Yi5S

Trabalho de Implementação

Gerador/Verificador de Assinaturas 

Implementar um gerador e verificador de assinaturas RSA em arquivos.
Assim, deve-se implementar um programa com as seguintes funcionalidades: 


---


Geração de chaves (mínimo de 1024 bits) 

*   Geração de chaves (mínimo de 1024 bits) 
*   Assinatura 

1.   Cálculo de hashes (função de hash SHA-3) 
2.   Assinatura da mensagem (cifração do hash)
2.   Formatação do resultado (caracteres especiais e informações para verificação) 

*   Verificação 

1.   Parsing do documento assinado (de acordo com a formatação usada
2.   Decifração da assinatura (decifração do hash) 
2.   Verificação (cálculo e comparação do hash do arquivo)  


---


Observações 1:

1.   Permite-se a utilização de bibliotecas públicas para aritmética modular e função de hash.
2.   Não é permitida a utilização de bibliotecas públicas, como OpenSSL, para primitivas de criptográficas de cifração e decifração assimétrica, e geração de chaves. 


---


Observações 2:

-> Implementarem  as seguintes primitivas;

*   geração de chaves com teste de primalidade (Miller-Rabin) 
*   cifração e decifração RSA
*   OAEP
*   Formatação/parsing

Biblioteca utilizadas:
 permite que randrange() manipular intervalos arbitrariamente grandes.


---
Observação 3:

![binary-left-shift.png](data:image/png;base64,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)

> bitwise operators 


No Python, os operadores bit a bit são usados para realizar cálculos bit a bit em inteiros. Os inteiros são primeiro convertidos em binários e, em seguida, as operações são realizadas bit a bit, daí o nome de operadores bit a bit.

Contextualização sobre criptografia e estonografia!


*   Cryptography

A criptografia trata de transformar uma mensagem em uma que seja legível apenas para aqueles com a chave certa. Todos os outros ainda podem ver a mensagem criptografada, mas não fará sentido para eles. Uma das primeiras formas de criptografia foi a cifra de substituição, como a cifra de César em homenagem a Júlio César. 

*   Steganography

A esteganografia é semelhante à criptografia porque também permite que você compartilhe mensagens secretas com o público desejado. No entanto, em vez de usar criptografia, ele esconde informações de forma inteligente em um meio que não atrai a atenção. Os exemplos incluem o uso de tinta invisível ou a escrita de um acróstico em que a primeira letra de cada palavra ou linha forma uma mensagem secreta

Contextualização sobre Criptografia Simétrica e Assimétrica



*   Criptografia Simétrica

O ciframento de uma mensagem (processo em que um conteúdo é criptografado) é baseado em 2 componentes (um algoritmo e uma chave de segurança). A criptografia simétrica faz uso de uma única chave, que é compartilhada entre o emissor e o destinatário de um conteúdo. Essa chave é uma cadeia própria de bits, que vai definir a forma como o algoritmo vai cifrar um conteúdo.

Como vantagem, a criptografia tem uma boa performance e a possibilidade de manter uma comunicação contínua entre várias pessoas simultaneamente. Caso a chave seja comprometida, basta efetuar a troca por uma nova, mantendo o algoritmo inicial

*   Criptografia Assimétrica

A criptografia assimétrica, também conhecida como criptografia de chave pública, é baseada em 2 tipos de chaves de segurança — uma privada e a outra pública. Elas são usadas para cifrar mensagens e verificar a identidade de um usuário.

Resumidamente falando, a chave privada é usada para decifrar mensagens, enquanto a pública é utilizada para cifrar um conteúdo. Assim, qualquer pessoa que precisar enviar um conteúdo para alguém precisa apenas da chave pública do seu destinatário, que usa a chave privada para decifrar a mensagem.

Esse sistema simples garante a privacidade dos usuários e aumenta a confiabilidade de uma troca de dados.

Contextualização sobre RSA e AES



1.   RSA

As chaves pública e privada são geradas com base na multiplicação de dois números primos. O resultado desta multiplicação será público mas, se o número for grande o suficiente, fatorar este número para descobrir os primos que multiplicamos para formá-lo pode demorar anos

2.   AES

O algoritmo descrito pelo AES é um algoritmo de chave simétrica, o que significa que a mesma chave é usada para criptografar e descriptografar os dados
"""

from random import getrandbits, randrange
from hashlib import sha3_512
from base64 import b64encode

config = dict()
config['BITS'] = 1024
config['MR_PROBABILITY'] = 20
config['e'] = 65537

#Miller-Rabin
def miller_rabin(a, s, d, n):
    a_to_power = pow(a, d, n)
    if a_to_power == 1:
        return True
    for i in range(s-1):
        if a_to_power == n - 1:
            return True
        a_to_power = (a_to_power * a_to_power) % n
    return a_to_power == n - 1

#Metodo utilizando a tecnica Miller-Rabin para verificar se o numero 'number' eh primo.
def is_prime(number):
    d = number - 1
    s = 0

    #Verifica se 'd' eh impar, se nao for executa um bitshift right e 's'
    while d % 2 == 0:
        d >>= 1
        s += 1

    #Repete o teste Miller-Rabin 'MR_PROBABILITY' vezes para probabilidade de 1-1/4**'MR_PROBABILITY' do numero 'number' ser primo
    for repeat in range(config['MR_PROBABILITY']):
        #Escolhe 'a' aleatoriamente dentro do range de 'number', exceto o numero 0
        a = 0
        while a == 0:
            a = randrange(number)

        #Se o teste falhar, eh numero composto
        if not miller_rabin(a, s, d, number):
            return False

    return True

#Metodo para gerar um numero primo aleatorio de n bits
def get_prime(nbits):
    while True:
        #Gera numero aleatorio 'number' com ate n bits.
        number = getrandbits(nbits)

        #Bitwise OR para aumentar a probabilidade do numero gerado 'number' ser primo
        #Seta o bit mais significativo para 1 garantindo n bits e numero alto.
        #Seta o bit menos significativo para 1 (impar), todo numero primo acima de 2 eh impar
        number |= 2**nbits | 1

        #Verifica se 'number' eh primo
        if is_prime(number):
            break
    return number

def gcd(e,t):
    if t == 0:
        return e
    else:
        return gcd(t,e%t)

def extend_euclid(a, b):
    if b == 0:
        return 1, 0, a
    else:
        x, y, q = extend_euclid(b, a % b)
        return y, x - (a // b) * y, q


def modinv(a, b):
    x, y, q = extend_euclid(a, b)
    if q != 1:
        return None
    else:
        return x % b

def generate_RSA_keys():
    #Numero primo 'p' de n bits
    p = get_prime(config['BITS']//2)

    #Numero primo 'q' de n bits diferente de 'p'
    while True:
        q = get_prime(config['BITS']//2)
        if q != p:
            break

    #RSA Modulus 'n'
    n = p * q

    t = ( p - 1 ) * ( q - 1 )

    for e in range(config['e'],t):
        if gcd(e,t)==1:
            break

    d = modinv(e, t)

    public_key = {'n' : n, 'e': e}
    private_key = {'n' : n, 'd': d}

    #print("Public Key: {}".format(public_key))
    #print("Private Key: {}\n".format(private_key))

    return (public_key, private_key)

def sign_message(mensagem, private_key):
    #Mensagem/informacao para ser assinada
    mensagem = b64encode(mensagem.encode())

    #Hash da mensagem de 512bits para caber na assinatura de 1024bits
    hash = int.from_bytes(sha3_512(mensagem).digest(), byteorder='big')

    #Assinatura com a chave privada
    assinatura = pow(hash, private_key['d'], private_key['n'])

    return (hash, assinatura)

def verify_signature(hash, assinatura, public_key):
    #Retorno da assinatura para o hash da mensagem original para posterior comparacao e validacao da assinatura
    hash_assinatura = pow(assinatura, public_key['e'], public_key['n'])

    if hash == hash_assinatura:
        return True
    return False

def main():

    #Gerar as chaves RSA publica e privada
    (public_key, private_key) = generate_RSA_keys()

    #Mensagem para assinar
    mensagem = "Mensagem secreta 1, 2, 3 !!!"

    #Assinar mensagem gerando o hash e a assinatura
    (hash, assinatura) = sign_message(mensagem, private_key)

    print("Mensagem para assinar: {}\n".format(mensagem))
    print("Hash da mensagem: {}\n".format(hex(hash)))
    print("Assinatura: {}\n".format(hex(assinatura)))
    print("Validade da assinatura: {}".format(verify_signature(hash, assinatura, public_key)))

if __name__ == '__main__':
    main()